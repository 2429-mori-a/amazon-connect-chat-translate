export default class MessageReceiptsUtil {
    constructor(logMetaData: any);
    logger: {
        options: any;
        debug(...args: any[]): any;
        info(...args: any[]): any;
        warn(...args: any[]): any;
        error(...args: any[]): any;
        advancedLog(...args: any[]): any;
        _shouldLog(level: any): boolean;
        _writeToClientLogger(level: any, logStatement: any): any;
        _log(level: any, args: any): any;
        _convertToSingleStatement(args: any): string;
        _convertToString(arg: any): any;
    };
    timeout: any;
    timeoutId: any;
    readSet: Set<any>;
    deliveredSet: Set<any>;
    readPromiseMap: Map<any, any>;
    deliveredPromiseMap: Map<any, any>;
    lastReadArgs: any;
    throttleInitialEventsToPrioritizeRead: any;
    throttleSendEventApiCall: (() => void) | null;
    /**
     * check if message is of type read or delivered event
     *
     * @param {string} eventType either INCOMING_READ_RECEIPT or INCOMING_DELIVERED_RECEIPT.
     * @param {Object} incomingData object contains messageDetails
     * @return {boolean} returns true if read or delivered event else false
    */
    isMessageReceipt(eventType: string, incomingData: Object): boolean;
    /**
     * check if message is for currentParticipantId
     *
     * @param {string} currentParticipantId of the contact
     * @param {Object} incomingData object contains messageDetails
     * @return {boolean} returns true if we need to display messageReceipt for the currentParticipantId
     *
    */
    getEventTypeFromMessageMetaData(messageMetadata: any): boolean;
    /**
     * check if message is for currentParticipantId
     *
     * @param {string} currentParticipantId of the contact
     * @param {Object} incomingData object contains messageDetails
     * @return {boolean} returns true if we need to display messageReceipt for the currentParticipantId
     *
    */
    shouldShowMessageReceiptForCurrentParticipantId(currentParticipantId: string, incomingData: Object): boolean;
    /**
     * Assumption: sendMessageReceipts are called in correct order of time the messages are Delivered or Read
     * Prioritize Read Event by Throttling Delivered events for 300ms but firing Read events immediately!
     *
     * @param {function} callback The callback fn to throttle and invoke.
     * @param {Array} args array of params [connectionToken, contentType, content, eventType, throttleTime]
     * @return {promise} returnPromise for Read and Delivered events
    */
    prioritizeAndSendMessageReceipt(ChatClientContext: any, callback: Function, ...args: any[]): promise;
    /**
     * Throttle for ${GlobalConfig.getMessageReceiptsThrottleTime()} and then fire Read and Delivered events
     *
     * @param {function} callback The callback fn to throttle and invoke.
     * @param {Array} args array of params [connectionToken, contentType, content, eventType, throttleTime]
    */
    sendMessageReceipts(ChatClientContext: any, callback: Function, ...args: any[]): void;
    /**
     * resolve All Delivered promises till messageId
     *
     * @param {string} messageId of the latest message receipt event
     * @param {Object} result of the latest message receipt event
    */
    resolveDeliveredPromises(messageId: string, result: Object, isError: any): void;
    /**
     * resolve All Read promises till messageId
     *
     * @param {string} messageId of the latest message receipt event
     * @param {Object} result of the latest message receipt event
    */
    resolveReadPromises(messageId: string, result: Object, isError: any): void;
    /**
     * resolve All promises till messageId
     *
     * @param {Map} promiseMap of either send or delivered promises
     * @param {string} messageId of the latest message receipt event
     * @param {Object} result of the latest message receipt event
    */
    resolvePromises(promiseMap: Map<any, any>, messageId: string, result: Object, isError: any): void;
    /**
     * getTranscript API call should hydrate readSet and deliveredSet
     *
     * @param {function} callback to call with getTranscript response object.
     * @param {boolean} shouldSendMessageReceipts decides whether to hydrate mappers or not
     * @return {function} function which takes in input response from API call and calls callback with response.
    */
    rehydrateReceiptMappers(callback: Function, shouldSendMessageReceipts: boolean): Function;
}
