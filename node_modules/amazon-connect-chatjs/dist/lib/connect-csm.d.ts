export const csmJsString: "(function() {\n  const global = self;\n  const csm = global.csm || {};\n  global.csm = csm;\n\n  csm.EVENT_TYPE = {\n    LOG: 'LOG',\n    METRIC: 'METRIC',\n    CONFIG: 'CONFIG',\n    WORKFLOW_EVENT: 'WORKFLOW_EVENT',\n    CUSTOM: 'CUSTOM',\n    CLOSE: 'CLOSE',\n    SET_AUTH: 'SET_AUTH',\n    SET_CONFIG: 'SET_CONFIG',\n  };\n\n  csm.UNIT = {\n    COUNT: 'Count',\n    SECONDS: 'Seconds',\n    MILLISECONDS: 'Milliseconds',\n    MICROSECONDS: 'Microseconds',\n  };\n})();\n\n(function() {\n  const global = self;\n  const csm = global.csm || {};\n  global.csm = csm;\n\n  const MAX_METRIC_DIMENSIONS = 10;\n\n  /** ********* Dimension Classes ***********/\n\n  const Dimension = function(name, value) {\n    csm.Util.assertExist(name, 'name');\n    csm.Util.assertExist(value, 'value');\n\n    this.name = name;\n    this.value = value == null ? 'null' : (value === '' ? ' ' : value.toString());\n  };\n\n\n  /** ********* Metric Classes ***********/\n\n  const Metric = function(metricName, unit, value, dedupeOptions) {\n    csm.Util.assertExist(metricName, 'metricName');\n    csm.Util.assertExist(value, 'value');\n    csm.Util.assertExist(unit, 'unit');\n    csm.Util.assertTrue(csm.Util.isValidUnit(unit));\n    if (dedupeOptions) {\n      csm.Util.assertInObject(dedupeOptions, 'dedupeOptions', 'dedupeIntervalMs');\n    }\n\n    this.metricName = metricName;\n    this.unit = unit;\n    this.value = value;\n    this.timestamp = new Date();\n    this.dimensions = csm.globalDimensions ? csm.Util.deepCopy(csm.globalDimensions): [];\n    this.namespace = csm.configuration.namespace;\n    this.dedupeOptions = dedupeOptions; // optional. { dedupeIntervalMs: (int; required), context: (string; optional) }\n\n    // Currently, CloudWatch can't aggregate metrics by a subset of dimensions.\n    // To bypass this limitation, we introduce the optional dimensions concept to CSM.\n    // The CSM metric publisher will publish a default metric without optional dimension\n    // For each optional dimension, the CSM metric publisher publishes an extra metric with that dimension.\n    this.optionalDimensions = csm.globalOptionalDimensions ? csm.Util.deepCopy(csm.globalOptionalDimensions): [];\n  };\n\n  Metric.prototype.addDimension = function(name, value) {\n    this._addDimensionHelper(this.dimensions, name, value);\n  };\n\n  Metric.prototype.addOptionalDimension = function(name, value) {\n    this._addDimensionHelper(this.optionalDimensions, name, value);\n  };\n\n  Metric.prototype._addDimensionHelper = function(targetDimensions, name, value) {\n    // CloudWatch metric allows maximum 10 dimensions\n    // http://docs.aws.amazon.com/AWSJavaScriptSDK/latest/AWS/CloudWatch.html#putMetricData-property\n    if ((this.dimensions.length + this.optionalDimensions.length) >= MAX_METRIC_DIMENSIONS) {\n      throw new csm.ExceedDimensionLimitException(name);\n    }\n\n    const existing = targetDimensions.find(function(dimension) {\n      return dimension.name === name;\n    });\n\n    if (existing) {\n      existing.value = value == null ? 'null' : (value === '' ? ' ' : value.toString());\n    } else {\n      targetDimensions.push(new Dimension(name, value));\n    }\n  };\n\n\n  /** ********* Telemetry Classes ***********/\n\n  const WorkflowEvent = function(params) {\n    this.timestamp = params.timestamp || new Date().getTime();\n    this.workflowType = params.workflow.type;\n    this.instanceId = params.workflow.instanceId;\n    this.userId = params.userId;\n    this.organizationId = params.organizationId;\n    this.accountId = params.accountId;\n    this.event = params.event;\n    this.appName = params.appName;\n    this.data = [];\n\n    // Convert 'data' map into the KeyValuePairList structure expected by the Lambda API\n    for (const key in params.data) {\n      if (Object.prototype.hasOwnProperty.call(params.data, key)) {\n        this.data.push({'key': key, 'value': params.data[key]});\n      }\n    }\n  };\n\n  /** ********* Exceptions ***********/\n\n  const NullOrUndefinedException = function(paramName) {\n    this.name = 'NullOrUndefinedException';\n    this.message = paramName + ' is null or undefined. ';\n  };\n  NullOrUndefinedException.prototype.toString = function() {\n    return this.name + ': ' + this.message;\n  };\n\n  const AssertTrueException = function() {\n    this.name = 'AssertTrueException';\n    this.message = 'Assertion failed. ';\n  };\n  AssertTrueException.prototype.toString = function() {\n    return this.name + ': ' + this.message;\n  };\n\n  const ExceedDimensionLimitException = function(dimensionName) {\n    this.name = 'ExceedDimensionLimitException';\n    this.message = 'Could not add dimension \\'' + dimensionName + '\\'. Metric has maximum 10 dimensions. ';\n  };\n  ExceedDimensionLimitException.prototype.toString = function() {\n    return this.name + ': ' + this.message;\n  };\n\n  const InitializationException = function() {\n    this.name = 'InitializationException';\n    this.message = 'Initialization failed. ';\n  };\n  InitializationException.prototype.toString = function() {\n    return this.name + ': ' + this.message;\n  };\n\n\n  csm.Dimension = Dimension;\n  csm.Metric = Metric;\n  csm.WorkflowEvent = WorkflowEvent;\n  csm.NullOrUndefinedException = NullOrUndefinedException;\n  csm.AssertTrueException = AssertTrueException;\n  csm.InitializationException = InitializationException;\n  csm.ExceedDimensionLimitException = ExceedDimensionLimitException;\n})();\n\n(function() {\n  const global = self;\n  const csm = global.csm || {};\n  global.csm = csm;\n\n  const validTimeUnits = [csm.UNIT.SECONDS, csm.UNIT.MILLISECONDS, csm.UNIT.MICROSECONDS];\n  const validUnits = validTimeUnits.concat(csm.UNIT.COUNT);\n\n  const Util = {\n    assertExist: function(value, paramName) {\n      if (value === null || value === undefined) {\n        throw new csm.NullOrUndefinedException(paramName);\n      }\n    },\n    assertTrue: function(value) {\n      if (!value) {\n        throw new csm.AssertTrueException();\n      }\n    },\n    assertInObject: function(obj, objName, key) {\n      if (obj === null || obj === undefined || typeof obj !== 'object') {\n        throw new csm.NullOrUndefinedException(objName);\n      }\n      if (key === null || key === undefined || !obj[key]) {\n        throw new csm.NullOrUndefinedException(`${objName}[${key}]`);\n      }\n    },\n    isValidUnit: function(unit) {\n      return validUnits.includes(unit);\n    },\n    isValidTimeUnit: function(unit) {\n      return validTimeUnits.includes(unit);\n    },\n    isEmpty: function(value) {\n      if (value !== null && typeof val === 'object') {\n        return Objects.keys(value).length === 0;\n      }\n      return !value;\n    },\n    deepCopy: function(obj) {\n      // NOTE: this will fail if obj has a circular reference\n      return JSON.parse(JSON.stringify(obj));\n    },\n\n    /**\n     * This function is used before setting the page location for default metrics and logs,\n     * and the APIs that set page location\n     * Can be overridden by calling csm.API.setPageLocationTransformer(function(){})\n     * @param {string}        pathname path for page location\n     * @return {string}       pathname provided\n     */\n    pageLocationTransformer: function(pathname) {\n      return pathname;\n    },\n\n    /**\n     * As of now, our service public claims only support for Firefox and Chrome\n     * Reference https://developer.mozilla.org/en-US/docs/Web/HTTP/Browser_detection_using_the_user_agent\n     *\n     * This function will only return firefox, chrome and others\n     *\n     * Best practice as indicated in MDN, \"Avoiding user agent detection\"\n     */\n    getBrowserDetails: function() {\n      const userAgent = window.navigator.userAgent;\n      const details = {};\n      if (userAgent.includes('Firefox') && !userAgent.includes('Seamonkey')) {\n        details.name = 'Firefox';\n        details.version = getBrowserVersion('Firefox');\n      } else if (userAgent.includes('Chrome') && !userAgent.includes('Chromium')) {\n        details.name = 'Chrome';\n        details.version = getBrowserVersion('Chrome');\n      }\n    },\n\n    randomId: function() {\n      return new Date().getTime() + '-' + Math.random().toString(36).slice(2);\n    },\n\n    getOrigin: function() {\n      return document.location.origin;\n    },\n\n    getReferrerUrl: function() {\n      const referrer = document.referrer || '';\n      return this.getURLOrigin(referrer);\n    },\n\n    getWindowParent: function() {\n      let parentLocation = '';\n      try {\n        parentLocation = window.parent.location.href;\n      } catch (e) {\n        parentLocation = '';\n      }\n      return parentLocation;\n    },\n\n    getURLOrigin: function(urlValue) {\n      let origin = '';\n      const originArray = urlValue.split( '/' );\n      if (originArray.length >= 3) {\n        const protocol = originArray[0];\n        const host = originArray[2];\n        origin = protocol + '//' + host;\n      }\n      return origin;\n    },\n\n  };\n\n  const getBrowserVersion = function(browserName) {\n    const userAgent = window.navigator.userAgent;\n    const browserNameIndex = userAgent.indexOf(browserName);\n    const nextSpaceIndex = userAgent.indexOf(' ', browserNameIndex);\n    if (nextSpaceIndex === -1) {\n      return userAgent.substring(browserNameIndex + browserName.length + 1, userAgent.length);\n    } else {\n      return userAgent.substring(browserNameIndex + browserName.length + 1, nextSpaceIndex);\n    }\n  };\n\n  csm.Util = Util;\n})();\n\n(function() {\n  const global = window;\n  const csm = global.csm || {};\n  global.csm = csm;\n\n  csm.globalDimensions = []; // These dimensions are added to all captured metrics.\n  csm.globalOptionalDimensions = [];\n  csm.initFailureDimensions = [];\n\n  const API = {\n    getWorkflow: function(workflowType, instanceId, data) {\n      return csm.workflow(workflowType, instanceId, data);\n    },\n\n    addMetric: function(metric) {\n      csm.Util.assertExist(metric, 'metric');\n      csm.putMetric(metric);\n    },\n\n    addMetricWithDedupe: function(metric, dedupeIntervalMs, context) {\n      csm.Util.assertExist(metric, 'metric');\n      csm.Util.assertExist(metric, 'dedupeIntervalMs');\n      // context is optional; if present it will only dedupe on metrics with the same context. ex.) tabId\n      metric.dedupeOptions = {dedupeIntervalMs, context: context || 'global'};\n      csm.putMetric(metric);\n    },\n\n    addCount: function(metricName, count) {\n      csm.Util.assertExist(metricName, 'metricName');\n      csm.Util.assertExist(count, 'count');\n\n      const metric = new csm.Metric(metricName, csm.UNIT.COUNT, count);\n      csm.putMetric(metric);\n    },\n\n    addCountWithPageLocation: function(metricName) {\n      csm.Util.assertExist(metricName, 'metricName');\n\n      const metric = new csm.Metric(metricName, csm.UNIT.COUNT, 1.0);\n      metric.addDimension('WindowLocation', csm.Util.pageLocationTransformer(window.location.pathname));\n      csm.putMetric(metric);\n    },\n\n    addError: function(metricName, count) {\n      csm.Util.assertExist(metricName, 'metricName');\n\n      if (count === undefined || count == null) {\n        count = 1.0;\n      }\n      const metric = new csm.Metric(metricName, csm.UNIT.COUNT, count);\n      metric.addDimension('Metric', 'Error');\n      csm.putMetric(metric);\n    },\n\n    addSuccess: function(metricName) {\n      API.addError(metricName, 0);\n    },\n\n    addTime: function(metricName, time, unit) {\n      csm.Util.assertExist(metricName, 'metricName');\n      csm.Util.assertExist(time, 'time');\n\n      let timeUnit = csm.UNIT.MILLISECONDS;\n      if (unit && csm.Util.isValidTimeUnit(unit)) {\n        timeUnit = unit;\n      }\n      const metric = new csm.Metric(metricName, timeUnit, time);\n      metric.addDimension('Metric', 'Time');\n      csm.putMetric(metric);\n    },\n\n    addTimeWithPageLocation: function(metricName, time, unit) {\n      csm.Util.assertExist(metricName, 'metricName');\n      csm.Util.assertExist(time, 'time');\n\n      let timeUnit = csm.UNIT.MILLISECONDS;\n      if (unit && csm.Util.isValidTimeUnit(unit)) {\n        timeUnit = unit;\n      }\n      const metric = new csm.Metric(metricName, timeUnit, time);\n      metric.addDimension('WindowLocation', csm.Util.pageLocationTransformer(window.location.pathname));\n      csm.putMetric(metric);\n    },\n\n    pageReady: function() {\n      if (window.performance && window.performance.now) {\n        const pageLoadTime = window.performance.now();\n        const metric = new csm.Metric('PageReadyLatency', csm.UNIT.MILLISECONDS, pageLoadTime);\n        metric.addDimension('WindowLocation', csm.Util.pageLocationTransformer(window.location.pathname));\n        csm.putMetric(metric);\n      }\n    },\n\n    setPageLocationTransformer: function(transformFunc) {\n      csm.Util.assertExist(transformFunc, 'transformFunc');\n      csm.Util.assertTrue((typeof transformFunc) === 'function');\n      csm.Util.pageLocationTransformer = transformFunc;\n    },\n\n    setGlobalDimensions: function(dimensions) {\n      csm.Util.assertExist(dimensions, 'dimensions');\n      csm.globalDimensions = dimensions;\n    },\n\n    setGlobalOptionalDimensions: function(dimensions) {\n      csm.Util.assertExist(dimensions, 'dimensions');\n      csm.globalOptionalDimensions = dimensions;\n    },\n\n    setInitFailureDimensions: function(dimensions) {\n      csm.Util.assertExist(dimensions, 'dimensions');\n      csm.initFailureDimensions = dimensions;\n    },\n\n    putCustom: function(endpoint, headers, data) {\n      csm.Util.assertExist(data, 'data');\n      csm.Util.assertExist(endpoint, 'endpoint');\n      csm.Util.assertExist(headers, 'headers');\n      csm.putCustom(endpoint, headers, data);\n    },\n\n    setAuthParams: function(authParams) {\n      csm.setAuthParams(authParams);\n    },\n\n    setConfig: function(key, value) {\n      csm.Util.assertExist(key, 'key');\n      csm.Util.assertExist(value, 'value');\n      if (!csm.configuration[key]) {\n        csm.setConfig(key, value); // set configuration variables such as accountId, instanceId, userId\n      }\n    },\n  };\n\n  csm.API = API;\n})();\n\n(function() {\n  const global = window;\n  const csm = global.csm || {};\n  global.csm = csm;\n\n  const WORKFLOW_KEY_PREFIX = 'csm.workflow';\n\n  /**\n   * Calculates the local storage key used to store a workflow of the specified type.\n   * @param {string} type of workflow\n   * @return {string} storage key\n   */\n  const getWorkflowKeyForType = function(type) {\n    return [\n      WORKFLOW_KEY_PREFIX,\n      type,\n    ].join('.');\n  };\n\n  /**\n   * Constructor for new Workflow objects.\n   *\n   * If you need to be able to share a workflow across tabs, it is recommended\n   * to use \"csm.workflow\" to create/hydrate your workflows instead.\n   * @param {string} type of workflow\n   * @param {string} instanceId of workflow\n   * @param {JSON} data blob associated with workflow\n   */\n  const Workflow = function(type, instanceId, data) {\n    this.type = type;\n    this.instanceId = instanceId || csm.Util.randomId();\n    this.instanceSpecified = instanceId || false;\n    this.eventMap = {};\n    this.data = data || {};\n\n    // Merge global dimensions into the data map.\n    const dimensionData = {};\n    csm.globalDimensions.forEach(function(dimension) {\n      dimensionData[dimension.name] = dimension.value;\n    });\n    csm.globalOptionalDimensions.forEach(function(dimension) {\n      dimensionData[dimension.name] = dimension.value;\n    });\n    this.data = this._mergeData(dimensionData);\n  };\n\n  /**\n   * Create a new workflow or rehydrate an existing shared workflow.\n   *\n   * @param {string} type The type of workflow to be created.\n   * @param {string} instanceId The instanceId of the workflow.  If not provided, it will be\n   *      assigned a random ID and will not be automatically saved to local storage.\n   *      If provided, we will attempt to load an existing workflow of the same type\n   *      from local storage and rehydrate it.\n   * @param {JSON} data An optional map of key/value pairs to be added as data to every\n   *      workflow event created with this workflow.\n   * @return {Workflow} workflow event\n   * NOTE: Only one workflow of each type can be stored at the same time, to avoid\n   *       overloading localStorage with unused workflow records.\n   */\n  csm.workflow = function(type, instanceId, data) {\n    let workflow = new Workflow(type, instanceId, data);\n\n    if (instanceId) {\n      const savedWorkflow = csm._loadWorkflow(type);\n      if (savedWorkflow && savedWorkflow.instanceId === instanceId) {\n        workflow = savedWorkflow;\n        workflow.addData(data || {});\n      }\n    }\n\n    return workflow;\n  };\n\n  csm._loadWorkflow = function(type) {\n    let workflow = null;\n    const workflowJson = localStorage.getItem(getWorkflowKeyForType(type));\n    const workflowStruct = workflowJson ? JSON.parse(workflowJson) : null;\n    if (workflowStruct) {\n      workflow = new Workflow(type, workflowStruct.instanceId);\n      workflow.eventMap = workflowStruct.eventMap;\n    }\n    return workflow;\n  };\n\n  /**\n   * Creates a new workflow event and returns it.  Then this workflow event is sent upstream\n   * to the CSMSharedWorker where it is provided to the backend.\n   *\n   * If an instanceId was specified when the workflow was created, this will also save the workflow\n   * and all of its events to localStorage.\n   *\n   * @param {string} event The name of the event that occurred.\n   * @param {JSON} data An optional free-form key attribute pair of metadata items that will be stored\n   *      and reported backstream with the workflow event.\n   * @return {WorkflowEvent} workflowEvent\n   */\n  Workflow.prototype.event = function(event, data) {\n    const mergedData = this._mergeData(data || {});\n    const workflowEvent = new csm.WorkflowEvent({\n      workflow: this,\n      event: event,\n      data: mergedData,\n      userId: csm.configuration.userId || '',\n      organizationId: csm.configuration.organizationId || '',\n      accountId: csm.configuration.accountId || '',\n      appName: csm.configuration.namespace || '',\n    });\n    csm.putWorkflowEvent(workflowEvent);\n    this.eventMap[event] = workflowEvent;\n    if (this.instanceSpecified) {\n      this.save();\n    }\n    return workflowEvent;\n  };\n\n  /**\n   * Creates a new workflow event and returns it, if the same event is not happened in ths past\n   * dedupeIntervalMs milliseconds.\n   * @param {string} event The name of the event that occurred.\n   * @param {JSON} data An optional free-form key attribute pair of metadata items that will be stored\n   * and reported backstream with the workflow event.\n   * @param {int} dedupeIntervalMs defaults to 200 MS\n   * @return {WorkflowEvent} workflowEvent\n   */\n  Workflow.prototype.eventWithDedupe = function(event, data, dedupeIntervalMs) {\n    const pastEvent = this.getPastEvent(event);\n    const now = new Date().getTime();\n    const interval = dedupeIntervalMs || 200;\n\n    // Crafting the expected workflow event data result\n    const mergedData = this._mergeData(data);\n    const expectedData = [];\n    for (const key in mergedData) {\n      if (Object.prototype.hasOwnProperty.call(mergedData, key)) {\n        expectedData.push({'key': key, 'value': mergedData[key]});\n      }\n    }\n\n    // Deduplicate same events that happened within interval\n    if (!pastEvent || (pastEvent && JSON.stringify(pastEvent.data) !== JSON.stringify(expectedData)) ||\n        (pastEvent && (now - pastEvent.timestamp > interval))) {\n      return this.event(event, data);\n    }\n    return null;\n  };\n\n  /**\n   * Get a past event if it exists in this workflow, otherwise returns null.\n   * This can be helpful to emit metrics in real time based on the differences\n   * between workflow event timestamps, especially for workflows shared across tabs.\n   * @param {string} event key to see if workflow exists for this event\n   * @return {WorkflowEvent} workflow event retrieved\n   */\n  Workflow.prototype.getPastEvent = function(event) {\n    return event in this.eventMap ? this.eventMap[event] : null;\n  };\n\n  /**\n   * Save the workflow to local storage. This only happens automatically when an\n   * instanceId is specified on workflow creation, however if this method is called\n   * explicitly by the client, the randomly generated workflow instance id can be\n   * used to retrieve the workflow later and automatic save on events will be enabled.\n   */\n  Workflow.prototype.save = function() {\n    this.instanceSpecified = true;\n    localStorage.setItem(getWorkflowKeyForType(this.type), JSON.stringify(this));\n  };\n\n  /**\n   * Remove this workflow if it is the saved instance for this workflow type in localStorage.\n   */\n  Workflow.prototype.close = function() {\n    const storedWorkflow = csm._loadWorkflow(this.type);\n    if (storedWorkflow && storedWorkflow.instanceId === this.instanceId) {\n      localStorage.removeItem(getWorkflowKeyForType(this.type));\n    }\n  };\n\n  Workflow.prototype.addData = function(data) {\n    for (const key in data) {\n      if (Object.prototype.hasOwnProperty.call(data, key)) {\n        this.data[key] = data[key];\n      }\n    }\n  };\n\n  Workflow.prototype._mergeData = function(data) {\n    const mergedData = {};\n    let key = null;\n    for (key in this.data) {\n      if (Object.prototype.hasOwnProperty.call(this.data, key)) {\n        mergedData[key] = this.data[key] == null ? 'null' : (this.data[key] === '' ? ' ' : this.data[key].toString());\n      }\n    }\n    for (key in data) {\n      if (Object.prototype.hasOwnProperty.call(data, key)) {\n        mergedData[key] = data[key] == null ? 'null' : (data[key] === '' ? ' ' : data[key].toString());\n      }\n    }\n    return mergedData;\n  };\n})();\n\n(function() {\n  const global = window;\n  const csm = global.csm || {};\n  global.csm = csm;\n\n  let worker = null;\n  let portId = null;\n\n  const MAX_INIT_MILLISECONDS = 5000;\n  const preInitTaskQueue = [];\n  csm.configuration = {};\n\n  /**\n   * Initialize CSM variables\n   * @param {object} params for CSM\n   * @params.namespace Define your metric namespace used in CloudWatch metrics\n   * @params.sharedWorkerUrl Specify the relative url to the connect-csm-worker.js file in your service\n   * @params.endpoint Specify an LDAS endpoint to use.\n   * @params.dryRunMode When CSM is initialized with dry run mode, it won't actually publish metrics.\n   * @params.defaultMetrics Enable default metrics. Default to false.\n   */\n  csm.initCSM = function(params) {\n    csm.Util.assertExist(params.namespace, 'namespace');\n    csm.Util.assertExist(params.sharedWorkerUrl, 'sharedWorkerUrl');\n    csm.Util.assertExist(params.endpoint, 'endpoint');\n\n    try {\n      console.log('Starting csm shared worker with', params.sharedWorkerUrl);\n      worker = new SharedWorker(params.sharedWorkerUrl, 'CSM_SharedWorker');\n      worker.port.start();\n    } catch (e) {\n      console.log('Failed to initialize csm shared worker with', params.sharedWorkerUrl);\n      console.log(e.message);\n    }\n\n    /**\n     * Configure shared worker\n     */\n    csm.configuration = {\n      namespace: params.namespace,\n      userId: params.userId || '',\n      accountId: params.accountId || '',\n      organizationId: params.organizationId || '',\n      endpointUrl: params.endpoint || null,\n      batchSettings: params.batchSettings || null,\n      addPageVisibilityDimension: params.addPageVisibilityDimension || false,\n      addUrlDataDimensions: params.addUrlDataDimensions || false,\n      dryRunMode: params.dryRunMode || false, // When csm is in dryRunMode it won't actually publish metrics to CSM\n    };\n\n    postEventToWorker(csm.EVENT_TYPE.CONFIG, csm.configuration);\n\n    /**\n     * Receive message from shared worker\n     * @param {MessageEvent} messageEvent from shared worker\n     */\n    worker.port.onmessage = function(messageEvent) {\n      const messageType = messageEvent.data.type;\n      onMessageFromWorker(messageType, messageEvent.data);\n    };\n\n    /**\n     * Inform shared worker window closed\n     */\n    global.onbeforeunload = function() {\n      worker.port.postMessage(\n          {\n            type: csm.EVENT_TYPE.CLOSE,\n            portId: portId,\n          },\n      );\n    };\n\n    /**\n     * Check if initialization success\n     */\n    global.setTimeout(function() {\n      if (!isCSMInitialized()) {\n        console.log('[FATAL] CSM initialization failed! Please make sure the sharedWorkerUrl is reachable.');\n      }\n    }, MAX_INIT_MILLISECONDS);\n\n    // Emit out of the box metrics\n    if (params.defaultMetrics) {\n      emitDefaultMetrics();\n    }\n  };\n  // Final processing before sending to SharedWorker\n  const processMetric = function(metric) {\n    if (csm.configuration.addPageVisibilityDimension && document.visibilityState) {\n      metric.addOptionalDimension('VisibilityState', document.visibilityState);\n    }\n  };\n\n  const processWorkflowEvent = function(event) {\n    if (csm.configuration.addUrlDataDimensions) {\n      event.data.push({'key': 'ReferrerUrl', 'value': csm.Util.getReferrerUrl()});\n      event.data.push({'key': 'Origin', 'value': csm.Util.getOrigin()});\n      event.data.push({'key': 'WindowParent', 'value': csm.Util.getWindowParent()});\n    }\n    if (['initFailure', 'initializationLatencyInfo'].includes(event.event)) {\n      csm.initFailureDimensions.forEach((dimension) => {\n        Object.keys(dimension).forEach((key) => {\n          event.data.push({'key': key, 'value': dimension[key]});\n        });\n      });\n    }\n    return event;\n  };\n\n  csm.putMetric = function(metric) {\n    processMetric(metric);\n    postEventToWorker(csm.EVENT_TYPE.METRIC, metric);\n  };\n\n  csm.putLog = function(log) {\n    postEventToWorker(csm.EVENT_TYPE.LOG, log);\n  };\n\n  csm.putWorkflowEvent = function(event) {\n    const processedEvent = processWorkflowEvent(event);\n    postEventToWorker(csm.EVENT_TYPE.WORKFLOW_EVENT, processedEvent);\n  };\n\n  csm.putCustom = function(endpoint, headers, data) {\n    postEventToWorker(csm.EVENT_TYPE.CUSTOM, data, endpoint, headers);\n  };\n\n  csm.setAuthParams = function(authParams) {\n    postEventToWorker(csm.EVENT_TYPE.SET_AUTH, authParams);\n  };\n\n  csm.setConfig = function(key, value) {\n    csm.configuration[key] = value;\n    postEventToWorker(csm.EVENT_TYPE.SET_CONFIG, {key, value});\n  };\n  /** **********************  PRIVATE METHODS  ************************/\n\n  const onMessageFromWorker = function(messageType, data) {\n    if (messageType === csm.EVENT_TYPE.CONFIG) {\n      portId = data.portId;\n      onCSMInitialized();\n    }\n  };\n\n  const onCSMInitialized = function() {\n    // Purge the preInitTaskQueue\n    preInitTaskQueue.forEach(function(task) {\n      postEventToWorker(task.type, task.message, task.endpoint, task.headers);\n    });\n\n    // TODO:  Capture on errors and publish log to shared worker\n    /**\n            window.onerror = function(message, fileName, lineNumber, columnNumber, errorstack) {\n                var log = new csm.Log(message, fileName, lineNumber, columnNumber, errorstack.stack);\n                csm.putLog(log);\n            };\n        */\n  };\n\n  /**\n   * Emit out of the box metrics automatically\n   *\n   * TODO allow configuration\n   */\n  const emitDefaultMetrics = function() {\n    window.addEventListener('load', function() {\n      // loadEventEnd is avaliable after the onload function finished\n      // https://www.w3.org/TR/navigation-timing-2/#processing-model\n      // https://developer.mozilla.org/en-US/docs/Web/API/PerformanceNavigationTiming\n      global.setTimeout(function() {\n        try {\n          const perfData = window.performance.getEntriesByType('navigation')[0];\n          const pageLoadTime = perfData.loadEventEnd - perfData.startTime;\n          const connectTime = perfData.responseEnd - perfData.requestStart;\n          const domRenderTime = perfData.domComplete - perfData.domInteractive;\n          csm.API.addCountWithPageLocation('PageLoad');\n          csm.API.addTimeWithPageLocation('PageLoadTime', pageLoadTime);\n          csm.API.addTimeWithPageLocation('ConnectTime', connectTime);\n          csm.API.addTimeWithPageLocation('DomRenderTime', domRenderTime);\n        } catch (err) {\n          console.log('Error emitting default metrics', err);\n        }\n      }, 0);\n    });\n  };\n\n  /**\n   * Try posting message to shared worker\n   * If shared worker hasn't been initialized, put the task to queue to be clean up once initialized\n   * @param {csm.EVENT_TYPE} eventType for CSM\n   * @param {object} message event following type of eventType\n   * @param {string} [endpoint] optional parameter for putCustom function (put any data to specified endpoint)\n   * @param {object} [headers] optional parameter for putCustom function\n   */\n  const postEventToWorker = function(eventType, message, endpoint, headers) {\n    if (eventType === csm.EVENT_TYPE.CONFIG || isCSMInitialized()) {\n      worker.port.postMessage(\n          {\n            type: eventType,\n            portId: portId,\n            message: message,\n            endpoint: endpoint,\n            headers: headers,\n          },\n      );\n    } else {\n      preInitTaskQueue.push({\n        type: eventType,\n        message: message,\n        endpoint: endpoint,\n        headers: headers,\n      });\n    }\n  };\n\n  const isCSMInitialized = function() {\n    return portId !== null;\n  };\n})()";
